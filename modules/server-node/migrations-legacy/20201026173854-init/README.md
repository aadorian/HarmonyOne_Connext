# Migration `20201026173854-init`

This migration has been generated by LayneHaber at 10/26/2020, 11:38:54 AM.
You can check out the [state of the schema](./schema.prisma) after the migration.

## Database Steps

```sql
CREATE TABLE "public"."balance" (
"participant" text   NOT NULL ,
"assetId" text   NOT NULL ,
"to" text   NOT NULL ,
"amount" text   NOT NULL ,
"processedDeposit" text   NOT NULL ,
"channelAddress" text   NOT NULL ,
PRIMARY KEY ("participant","channelAddress","assetId")
)

CREATE TABLE "public"."channel" (
"channelAddress" text   NOT NULL ,
"publicIdentifierA" text   NOT NULL ,
"publicIdentifierB" text   NOT NULL ,
"participantA" text   NOT NULL ,
"participantB" text   NOT NULL ,
"assetIds" text   NOT NULL ,
"timeout" text   NOT NULL ,
"nonce" integer   NOT NULL ,
"merkleRoot" text   NOT NULL ,
"channelFactoryAddress" text   NOT NULL ,
"channelMastercopyAddress" text   NOT NULL ,
"transferRegistryAddress" text   NOT NULL ,
"chainId" integer   NOT NULL ,
"providerUrl" text   NOT NULL ,
"defundNonce" text   NOT NULL ,
PRIMARY KEY ("channelAddress")
)

CREATE TABLE "public"."update" (
"channelAddress" text   ,
"channelAddressId" text   NOT NULL ,
"fromIdentifier" text   NOT NULL ,
"toIdentifier" text   NOT NULL ,
"type" text   NOT NULL ,
"nonce" integer   NOT NULL ,
"amountA" text   NOT NULL ,
"amountB" text   NOT NULL ,
"toA" text   NOT NULL ,
"toB" text   NOT NULL ,
"assetId" text   NOT NULL ,
"signatureA" text   ,
"signatureB" text   ,
"totalDepositsAlice" text   ,
"totalDepositsBob" text   ,
"transferAmountA" text   ,
"transferAmountB" text   ,
"transferToA" text   ,
"transferToB" text   ,
"transferId" text   ,
"transferDefinition" text   ,
"transferTimeout" text   ,
"transferInitialState" text   ,
"transferEncodings" text   ,
"merkleProofData" text   ,
"meta" text   ,
"responder" text   ,
"transferResolver" text   ,
"merkleRoot" text   ,
PRIMARY KEY ("channelAddressId","nonce")
)

CREATE TABLE "public"."transfer" (
"transferId" text   NOT NULL ,
"routingId" text   NOT NULL ,
"amountA" text   NOT NULL ,
"amountB" text   NOT NULL ,
"toA" text   NOT NULL ,
"toB" text   NOT NULL ,
"initialStateHash" text   NOT NULL ,
"channelAddress" text   ,
"channelAddressId" text   NOT NULL ,
"createUpdateChannelAddressId" text   ,
"createUpdateNonce" integer   ,
"resolveUpdateChannelAddressId" text   ,
"resolveUpdateNonce" integer   ,
PRIMARY KEY ("transferId")
)

CREATE TABLE "public"."event-subscription" (
"id" text   NOT NULL ,
"event" text   NOT NULL ,
"publicIdentifier" text   NOT NULL ,
"url" text   NOT NULL ,
PRIMARY KEY ("id")
)

CREATE TABLE "public"."onchain_transaction" (
"transactionHash" text   NOT NULL ,
"to" text   NOT NULL ,
"from" text   NOT NULL ,
"data" text   NOT NULL ,
"value" text   NOT NULL ,
"chainId" integer   NOT NULL ,
"nonce" integer   NOT NULL ,
"gasLimit" text   NOT NULL ,
"gasPrice" text   NOT NULL ,
"timestamp" text   ,
"raw" text   ,
"blockHash" text   ,
"blockNumber" integer   ,
"contractAddress" text   ,
"transactionIndex" integer   ,
"root" text   ,
"gasUsed" text   ,
"logsBloom" text   ,
"logs" text   ,
"cumulativeGasUsed" text   ,
"byzantium" boolean   ,
"status" text   NOT NULL DEFAULT E'submitted',
"reason" text   NOT NULL ,
"error" text   ,
"channelAddress" text   NOT NULL ,
PRIMARY KEY ("transactionHash")
)

CREATE TABLE "public"."configuration" (
"id" integer   NOT NULL ,
"mnemonic" text   NOT NULL ,
PRIMARY KEY ("id")
)

CREATE TABLE "public"."node_index" (
"index" integer   NOT NULL ,
"publicIdentifier" text   NOT NULL ,
PRIMARY KEY ("index")
)

CREATE UNIQUE INDEX "channel.publicIdentifierA_publicIdentifierB_chainId_unique" ON "public"."channel"("publicIdentifierA", "publicIdentifierB", "chainId")

CREATE UNIQUE INDEX "channel.participantA_participantB_chainId_unique" ON "public"."channel"("participantA", "participantB", "chainId")

CREATE UNIQUE INDEX "update_channelAddress_unique" ON "public"."update"("channelAddress")

CREATE UNIQUE INDEX "transfer.routingId_channelAddressId_unique" ON "public"."transfer"("routingId", "channelAddressId")

CREATE UNIQUE INDEX "transfer_createUpdateChannelAddressId_createUpdateNonce_unique" ON "public"."transfer"("createUpdateChannelAddressId", "createUpdateNonce")

CREATE UNIQUE INDEX "transfer_resolveUpdateChannelAddressId_resolveUpdateNonce_unique" ON "public"."transfer"("resolveUpdateChannelAddressId", "resolveUpdateNonce")

CREATE UNIQUE INDEX "event-subscription.publicIdentifier_event_unique" ON "public"."event-subscription"("publicIdentifier", "event")

CREATE UNIQUE INDEX "onchain_transaction.transactionHash_unique" ON "public"."onchain_transaction"("transactionHash")

CREATE UNIQUE INDEX "onchain_transaction.from_nonce_unique" ON "public"."onchain_transaction"("from", "nonce")

CREATE UNIQUE INDEX "configuration.mnemonic_unique" ON "public"."configuration"("mnemonic")

CREATE UNIQUE INDEX "node_index.publicIdentifier_unique" ON "public"."node_index"("publicIdentifier")

ALTER TABLE "public"."balance" ADD FOREIGN KEY ("channelAddress")REFERENCES "public"."channel"("channelAddress") ON DELETE CASCADE ON UPDATE CASCADE

ALTER TABLE "public"."update" ADD FOREIGN KEY ("channelAddress")REFERENCES "public"."channel"("channelAddress") ON DELETE SET NULL ON UPDATE CASCADE

ALTER TABLE "public"."transfer" ADD FOREIGN KEY ("createUpdateChannelAddressId", "createUpdateNonce")REFERENCES "public"."update"("channelAddressId","nonce") ON DELETE SET NULL ON UPDATE CASCADE

ALTER TABLE "public"."transfer" ADD FOREIGN KEY ("resolveUpdateChannelAddressId", "resolveUpdateNonce")REFERENCES "public"."update"("channelAddressId","nonce") ON DELETE SET NULL ON UPDATE CASCADE

ALTER TABLE "public"."transfer" ADD FOREIGN KEY ("channelAddress")REFERENCES "public"."channel"("channelAddress") ON DELETE SET NULL ON UPDATE CASCADE

ALTER TABLE "public"."onchain_transaction" ADD FOREIGN KEY ("channelAddress")REFERENCES "public"."channel"("channelAddress") ON DELETE CASCADE ON UPDATE CASCADE
```

## Changes

```diff
diff --git schema.prisma schema.prisma
migration ..20201026173854-init
--- datamodel.dml
+++ datamodel.dml
@@ -1,0 +1,196 @@
+generator client {
+  provider        = "prisma-client-js"
+  previewFeatures = ["connectOrCreate"]
+  binaryTargets   = ["native"]
+}
+
+datasource db {
+  provider = ["postgresql", "sqlite"]
+  url = "***"
+}
+
+model Balance {
+  participant      String
+  assetId          String
+  to               String
+  amount           String
+  processedDeposit String
+  Channel          Channel @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddress   String
+
+  @@id([participant, channelAddress, assetId])
+  @@map(name: "balance")
+}
+
+model Channel {
+  channelAddress           String    @id
+  publicIdentifierA        String
+  publicIdentifierB        String
+  participantA             String
+  participantB             String
+  assetIds                 String
+  timeout                  String
+  nonce                    Int
+  merkleRoot               String
+  balances                 Balance[]
+  channelFactoryAddress    String
+  channelMastercopyAddress String
+  transferRegistryAddress  String
+  chainId                  Int
+  providerUrl              String
+  latestUpdate             Update
+  defundNonce              String
+
+  activeTransfers Transfer[]
+
+  OnchainTransaction OnchainTransaction[]
+  @@unique([publicIdentifierA, publicIdentifierB, chainId])
+  @@unique([participantA, participantB, chainId])
+  @@map(name: "channel")
+}
+
+model Update {
+  // COMMON PARAMS
+  channelAddress   String?
+  channel          Channel? @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddressId String // required for ID so that relation can be removed
+
+  fromIdentifier String
+  toIdentifier   String
+  type           String
+  nonce          Int
+
+  // balance
+  amountA String
+  amountB String
+  toA     String
+  toB     String
+
+  assetId    String
+  signatureA String?
+  signatureB String?
+
+  // DETAILS
+  // deposit details
+  totalDepositsAlice String?
+  totalDepositsBob String?
+
+  // create details
+  transferAmountA      String?
+  transferAmountB      String?
+  transferToA          String?
+  transferToB          String?
+  transferId           String?
+  transferDefinition   String?
+  transferTimeout      String?
+  transferInitialState String? // JSON string
+  transferEncodings    String?
+  merkleProofData      String? // proofs.join(",")
+  meta                 String?
+  responder            String?
+
+  // resolve details
+  transferResolver String?
+  merkleRoot       String?
+
+  // setup inferred from channel params
+
+  createdTransfer  Transfer? @relation("CreatedTransfer")
+  resolvedTransfer Transfer? @relation("ResolvedTransfer")
+
+  @@id([channelAddressId, nonce])
+  @@map(name: "update")
+}
+
+model Transfer {
+  transferId String @id
+  routingId  String
+
+  createUpdate  Update? @relation(name: "CreatedTransfer", fields: [createUpdateChannelAddressId, createUpdateNonce], references: [channelAddressId, nonce])
+  resolveUpdate Update? @relation(name: "ResolvedTransfer", fields: [resolveUpdateChannelAddressId, resolveUpdateNonce], references: [channelAddressId, nonce])
+
+  // balance
+  amountA String
+  amountB String
+  toA     String
+  toB     String
+
+  initialStateHash String
+
+  channel          Channel? @relation(fields: [channelAddress], references: [channelAddress])
+  channelAddress   String?
+  channelAddressId String // required for ID so that relation can be removed
+
+  // created will always exist
+  createUpdateChannelAddressId String?
+  createUpdateNonce            Int?
+
+  // resolved will not always exist
+  resolveUpdateChannelAddressId String?
+  resolveUpdateNonce            Int?
+
+  @@unique([routingId, channelAddressId])
+  @@map(name: "transfer")
+}
+
+model EventSubscription {
+  id               String @id @default(uuid())
+  event            String
+  publicIdentifier String
+  url              String
+
+  @@unique([publicIdentifier, event])
+  @@map(name: "event-subscription")
+}
+
+model OnchainTransaction {
+  // Response fields
+  transactionHash String @id
+  to              String
+  from            String
+  data            String
+  value           String
+  chainId         Int
+  nonce           Int
+  gasLimit        String
+  gasPrice        String
+
+  // Receipt fields
+  timestamp         String?
+  raw               String?
+  blockHash         String?
+  blockNumber       Int?
+  contractAddress   String?
+  transactionIndex  Int?
+  root              String?
+  gasUsed           String?
+  logsBloom         String?
+  logs              String?
+  cumulativeGasUsed String?
+  byzantium         Boolean?
+
+  // Channel fields
+  status         String  @default("submitted") // no enums
+  reason         String // no enums
+  error          String?
+  channelAddress String
+  channel        Channel @relation(fields: [channelAddress], references: [channelAddress])
+
+  @@unique(transactionHash)
+  @@unique([from, nonce])
+  @@map(name: "onchain_transaction")
+}
+
+model Configuration {
+  id       Int    @id
+  mnemonic String @unique
+
+  @@map(name: "configuration")
+}
+
+model NodeIndex {
+  index            Int    @id
+  publicIdentifier String @unique
+
+  @@map(name: "node_index")
+}
```


